# BASH
- [BASH](#bash)
    - [cat](#cat)
    - [tac](#tac)
    - [head](#head)
    - [tail](#tail)
    - [which](#which)
    - [whereis](#whereis)
    - [pipe](#pipe)
    - [wc](#wc)
    - [more](#more)
    - [cat](#cat-1)
    - [paste](#paste)
    - [tr (translate)](#tr-translate)
    - [cut](#cut)
    - [sort](#sort)
    - [uniq](#uniq)
    - [split](#split)
    - [fold](#fold)
    - [grep](#grep)
    - [egrep](#egrep)
    - [awk](#awk)
    - [sed](#sed)
    - [find](#find)
      - [Шпаргалка по команде find:](#шпаргалка-по-команде-find)
    - [| xargs](#-xargs)
    - [Шпаргалка по регуляркам:](#шпаргалка-по-регуляркам)


### cat
_вывести файл целиком_

    cat [<опции>] <имя файла>
        -n  < пронумеровать с пустыми строками
        -b  < пронумеровать непустые
        -s  < подряд идущие пустые строки в виде одной пустой строки
        -E  < добавляет $ в конец строки
        -T  < показать символы табуляции как "^I"

```bash 
    # вывести все строки кроме закомментированных
    cat ... | grep -v ^# | cat -s 
```

### tac 
_обратный порядок символов в строке_

### head 
    -n <num>    < количество строк
    -c <num>    < количество байт 
    -q          < не печатать заголовки файлов перед выводом (когда несколько файлов)

### tail
_прочитать конец файла_

    -n <num>    < количество строк
    -c <num>    < количество байт 
    -f          < интерактивный режим, постоянный цикл по считыванию файла 

### which   
_Поиск файла, который будет запущен, при выполнении команды_

```bash
    # что представляет собой команда shutdown
    $ which shutdown
/usr/sbin/shutdown
```
### whereis 
_путь до бинарника и мануалов_

    whereis <command>
            -b  < только бинарник 
            -s  < только исходники
            -m  < только маны
            -M  < список каталогов для поиска man-страниц
            -B  < список каталогов для поиска бинарников
            -s  < список каталогов для поиска исходников

```bash
    $ whereis shutdown
shutdown: /usr/sbin/shutdown /usr/share/man/man8/shutdown.8.gz /usr/share/man/man2/shutdown.2.gz
```

### pipe 
_для связи нескольких команд путем перенаправления stdout в stdin последующей команды_

    -n  < вывод номеров строк
    -t  < вывод табуляции как ^I

```bash
    $ cat /etc/ssh/sshd_config  | wc -l  # подсчет строк
                                | column # расположить вывод столбцами
```

### wc 
_количество строк, слов, байт_

    wc <options> <file_name>     
        -l  --lines     < только строк 
        -c  --bytes     < только байты
        -w  --words     < только слов
        -m  --chars     < только символы 

### more


### cat 
_объединить файлы_

    cat <file1> ... <fileN>

### paste
_объединяет два файла с разбивкой по колонкам (разделитель - табуляция)_
```bash
    paste <options> <file1> <file2>
    paste file1 file2 | cat -T  # показать символ табуляции (^I)

        -d :  < изменить разделитель на : (по умолчанию табуляция)
        -s    < выстроить файлы в строку 
```

### tr (translate) 
_Замена одних символов на другие_
```bash
    tr [OPTION]... STRING1 [STRING2]
    tr <char1> <char2> все вхождения char1 изменить на char2
        -c <SET1> <SET2>    < преобразует символ, не входящий в набор 1, в символы набора 2
exmp: echo "computer" | tr -c 'aeiouy' ' '
         o  u e
        -d  < удаляет символы (эквивалент tr <char> '')
    tr 'a-e' 'x' # может работать с диапазонами
```
### cut  
_извлекает часть файла или входного потока_

    cut OPTION... [FILE]...
        -d :        < определяет разделитель полей 
        -f <num>    < номер столбца для извлечения
        -b 8        < вывести из каждой строки первые 8 символов
```bash
    #exmp:        
    cat /proc/meminfo | cut -c 5-   # убрать с начала строки до 5 символа
    cat /proc/meminfo | rev | cut -c 3- | rev # убрать 2 символа с конца

```
### sort 

    sort <options> <file_name> 
    -r      < реверсивная сортировка
    -f      < игнорировать регистр
    -g      < сортировать по цифрам
    -u      < выводить уникальные строки
### uniq
_работа с дубликатами строк_

    -c      < перед каждой строкой выводить количество дубликатов
    -d      < выводить только дубликаты
    -u      < выводить только уникальные строки 

### split   
_разбиение файла на части_

    -b      < размер частей в байтах
    -l      < в строках
    -n      < количество частей 
    -d      < использовать числовой префикс вместо символьного

### fold  
_ограничивает выходной поток заданной ширины_

    -w 10
    -s будет стараться разбивать по пробелам

### grep 
_искать строки по условию и выводить_

    grep [OPTION]... PATTERNS [FILE]...
        <string> <filename>     < поиск набора символов в файле
        -i  < регистронезависимый поиск
        -c  < подсчет количества строк с найденным набором символов
        -n      < номера найденных строк 
        -v      < вывести всё кроме 
        -A<num> < сколько строк после
        -B<num> < сколько строк до
        -C<num> < сколько до и после
        -r      < рекурсивный поиск по файлам
        -R  < рекурсивный поиск в т.ч. по симлинкам

### egrep

>    _можно указать несколько паттернов_
> 
    = grep -i -E аналогично egrep

### awk 
_поточный текстовый редактор_

[HANDY ONE-LINE SCRIPTS FOR AWK (awk1line.txt)](./appendix/awk1line.txt)

    awk '{print $1}'            < – напечатать первый блок
    awk '{print $1 $2}'         < – напечатать первый и второй блоки 
    awk '{print $2,$NF}'        < – напечатать первый и последний блоки
    awk 'FS=":" {print $2,$NF}' < – аналог если разделитель двоеточие
    awk 'FNR==2 {print $0}'     < – напечатать вторую строку
    awk '{print $0}' ORS=' '    < – напечатать файл в одну строку

    Переменные:
    FS  – Разделитель полей (по умолчанию пробел)
    NF  – Количество строк 
    FNR – Количество строк в файле
    ORS – Выходной разделитель

### sed 
_поточный текстовый редактор stream editor_

    sed [OPTION]... {script-only-if-no-other-script} [input-file]...
    sed –n 10p              < – показать десятую строку
    Команда d – удалить
        sed -e '10 d'           < – удалить десятую строку
        sed -e '2,4 d'          < – удалить 2,3,4 строки
        sed -e '/pts/ d'        < – удалить строки в которых есть pts
        sed -e '/^$/d;/^\s*#/d' < – удалить пустые и закомментированные строки
    Команда s – заменить
        sed -e "s/USER/user/g   < – заменить USER на user
        sed -e "1,3 s/USER/user/    < – заменить USER на user только в строках 1,2,3
        sed -e "3,$ s/USER/user/    < – заменить начиная с третьей строки и до конца

        -i[SUFFIX], --in-place[=SUFFIX] < edit files in place (makes backup if SUFFIX supplied)
    
        -n 48p      < вывести 48 строку
        -n 48,51p   < вывести строки с 48 по 51
        -e 48,51d   < удалить строки


```bash
    # Изменение файла:
    # выполнить команду <command> и заменить содержимое файла file.txt
    sed -i <command> file.txt 
    # заменить содержимое файла и сохранить бекап в file.txt.bak 
    sed -i.bak <command> file.txt
    sed -i.bak '/^PrivateKey=/s/<insert_key>/123456/' ./test.txt    
```

### find    
_поиск файлов по файловой системе_

    find [path] [options] критерий шаблон [действие]

    options:
        -maxdepth   -- максимальная глубина поиска по подкаталогам
        -depth      - искать сначала в текущем каталоге, затем в подкаталогах
        -mount      - искать файлы только в этой ФС
        -print      - выводить полные имена файлов
        -type f     - искать файлы
        -type d     - искать каталоги

    критерии:
        -name       - поиск файлов по имени
        -perm       - поиск файлов в linux по режиму доступа
        -user       - поиск по владельцу
        -mtime      - поиск по времени модификации файла 
        -newer      - найти файлы новее, чем указанный
        -size       - поиск файлов в linux по размеру

#### Шпаргалка по команде find:

    find . -type f      < найти все файлы
    find . -type d      < найти все директории
    find . -maxdepth 2 -mindepth 1      < ограничить глубину поиска
    find . -type f -mtime +10           < найти файлы с mtime старше 10 дней
    find . -type f -mtime +10 -mtime -20    <   найти файлы с mtime в диапазоне от 10 до 20 дней
    find . -type f -delete              < удалить найденное
    find . -type f -exec echo "founded {}" \;   < передать найденное внешней команде 
    find ./* -type f | xargs -0 -i mv {} {}.rename  < обработать найденное через xargs

    Удаление пустых папок:
    find . -type d -empty -delete
    find . -type d -empty rmdir {} \;
    Удаление файлов по маске, игнорируя регистр символов:
    find . -type f -name -iname "**.LnK*" -delete

### | xargs

    [команда_генератор_списка] | xargs [опции_xargs] [команда]

    find . -name "*.sh" | xargs rm -rf


### Шпаргалка по регуляркам:
| | |
|---|---|
| [0-9] |  — Любая цифра |
| [a-z][A-Z][a-zA-Z] | — строчные буквы, прописные буквы, и те и другие буквы |
| [^0-9][^a-zA-Z] | — всё кроме цифр, всё кроме букв (“крышечка” – отрицание) |
| {2-5}             |     — Модификатор “число повторений” |
| [0-9]{2}          |     — Число из двух цифр |
| [а-яА-Я]{2,5}     |     — Слово не короче двух и не длиннее пяти букв |
|||
| ^                 |     — Начало строки |
| $                 |     — Конец строки |
| ^Otus             |     — Строка начинается со слова Otus |
| Otus$             |     — Строка заканчивается словом Otus |
| ^Otus$            |     — Строка состоит из слова Otus и больше в ней ничего нет
| .                 |     — заменяет любой символ (любой один символ) |
| \*                |     — модификатор “ноль или больше“ |
| \+                |     — модификатор “один или больше” |
| O.us              |     — Подходит: Otus, Opus, Oous. Не подходит: Ous, Ottus |
| O.*us             |     — Подходит: Otus, Opus, Oous, Ottus, Ous. Не подходит: OttUS Otsu |
| O.+us             |     — Подходит: Otus, Opus, Oous, Ottus. Не подходит: Ous Otsu |
|||
| [0-9]*             |    — Ноль или больше цифр |
| [0-9]+[a-zA-Z]{2}  |    — Как минимум 1 цифра (или больше одной) и ровно 2 буквы |
| (42\|31)             |    — Вертикальная черта \| означает “или”. В данном примере ищем или 42 или 31 |