cat tac     < вывести файл целиком
head tail   < начало и конец файла
sort uniq   < сортировка и удаление повторов
wc          < счётчик строк, слов и байт в тексте
grep        < поиск по образцу
rev         < перевернуть строку
paste       < объединить файлы построчно
cut         < вырезать данные из текстa
tr          < замена или удаление символов



cat [<опции>] <имя файла>
    -n  < пронумеровать с пустыми строками
    -b  < пронумеровать непустые
    -s  < подряд идущие пустые строки в виде одной пустой строки
    -E  < добавляет $ в конец строки
    -T  < показать символы табуляции как "^I"

cat ... | grep -v ^# | cat -s 

tac обратный порядок

head 
    -n <num>    < количество строк
    -c <num>    < количество байт 
    -q          < не печатать заголовки файлов перед выводом (когда несколько файлов)
tail
    -n <num>    < количество строк
    -c <num>    < количество байт 
    -f          < интерактивный режим, постоянный цикл по считыванию файла 

which   # что представляет команда. Поиск файла, который будет запущен, при запуске команды
whereis # путь до бинарника и мануалов
    -b  < только бинарник 
    -s  < только исходники
    -m  < только маны
    -M  < список каталогов для поиска man-страниц
    -B  < список каталогов для поиска бинарников
    -s  < список каталогов для поиска исходников

pipe # для связи нескольких команд путем перенаправления stdout в stdin последующей команды
cat -n ... | wc -l подсчет строк 
        | column по столбцам
    -t выводит табы как ^I

wc <options> <file_name>     # количество строк, слов, байт
    -l  < только строк 
    -c  < только символов
    -w  < только слов
    -b  < только байт 

more

cat file1 file2
paste <file1> <file2>   # объединяет два файла с разбивкой по колонкам (табуляция)
paste file1 file2 | cat -T 

    -d:     < изменить разделитель на : (по умолчанию табуляция)
    -s      < выстроить в строку 

tr (translate) Замена одних символов на другие
    <char1> <char2> все вхождения char1 изменить на char2
    -c SET1 SET2    < преобразует символ не входящий в набор 1, в символы набора 2
        exm: echo "computer" | tr -c 'aeiouy' ' '
            o  u e
    -d              < удаляет символы (эквивалент tr <char> '')
    может работать с диапазонами: tr 'a-e' 'x'

cut  извлекает часть файла или входного потока
    -d :        < определяет разделитель полей 
    -f <num>    < номер столбца для извлечения
    -b 8        < вывести из каждой строки первые 8 символов

sort <options> <file_name> 
    -r      < реверсивная сортировка
    -f      < игнорировать регистр
    -g      < сортировать по цифрам
    -u      < выводить уникальные строки
uniq
    -c      < перед каждой строкой выводить количество дубликатов
    -d      < выводить только дубликаты
    -u      < выводить только уникальные строки 

split   # разбиение файла на части
    -b      < размер частей в байтах
    -l      < в строках
    -n      < количество частей 
    -d      < использовать числовой префикс вместо символьного

exm:        
cat /proc/meminfo | cut  -c 5-
            # убрать 3 символа с конца
cat /proc/meminfo | rev | cut -c 3- | rev 
            
fold  ограничивает выходной поток заданной ширины
    -w 10
    -s будет стараться разбивать по пробелам


grep искать строки по условию и выводить
    <string> <filename>     < поиск набора символов в файле
    -i регистронезависимый поиск
    -c      < подсчет количества строк с найденным набором символов
    -n      < номера найденных строк 
    -v      < вывести всё кроме 
    -A<num> < сколько строк после
    -B<num> < сколько строк до
    -C<num> < сколько до и после
    -r      < рекурсивный поиск по файлам
    -R рекурсивный поиск в т.ч. по симлинкам

egrep    можно указать несколько паттернов
    = grep -i -E аналогично egrep 

awk поточный текстовый редактор

awk '{print $1}'            < – напечатать первый блок
awk '{print $1 $2}'         < – напечатать первый и второй блоки 
awk '{print $2,$NF}'        < – напечатать первый и последний блоки
awk 'FS=":" {print $2,$NF}' < – аналог если разделитель двоеточие
awk 'FNR==2 {print $0}'     < – напечатать вторую строку
awk '{print $0}' ORS=' '    < – напечатать файл в одну строку

Переменные:
FS  – Разделитель полей (по умолчанию пробел)
NF  – Количество строк 
FNR – Количество строк в файле
ORS – Выходной разделитель

sed поточный текстовый редактор stream editor
sed –n 10p              < – показать десятую строку
Команда d – удалить
sed -e '10 d'           < – удалить десятую строку
sed -e '2,4 d'          < – удалить 2,3,4 строки
sed -e '/pts/ d'        < – удалить строки в которых есть pts
sed -e '/^$/d;/^\s*#/d' < – удалить пустые и закомментированные строки
Команда s – заменить
sed -e "s/USER/user/g   < – заменить USER на user
sed -e "1,3 s/USER/user/    < – заменить USER на user только в строках 1,2,3
sed -e "3,$ s/USER/user/    < – заменить начиная с третьей строки и до конца

sed -i.bak '/^PrivateKey=/s/<insert_key>/123456/' ./test.txt

Изменение файла:
sed -i '<command>’ file.txt     < выполнить команду <command> и заменить содержимое файла file.txt
sed -i.bak '<command>’ file.txt < заменить содержимое файла и сохранить бекап в file.txt.bak

    -n 48p вывести 48 строку
    -n 48,51p
    -e 48,51d

find    # поиск файлов по файловой системе
find [path] [options] критерий шаблон [действие]

options:
-maxdepth   -- максимальная глубина поиска по подкаталогам
-depth      - искать сначала в текущем каталоге, затем в подкаталогах
-mount      - искать файлы только в этой ФС
-print      - выводить полные имена файлов
-type f     - искать файлы
-type d     - искать каталоги

критерии:
-name       - поиск файлов по имени
-perm       - поиск файлов в linux по режиму доступа
-user       - поиск по владельцу
-mtime      - поиск по времени модификации файла 
-newer      - найти файлы новее, чем указанный
-size       - поиск файлов в linux по размеру

Шпаргалка по команде find:
find . -type f      < найти все файлы
find . -type d      < найти все директории
find . -maxdepth 2 -mindepth 1      < ограничить глубину поиска
find . -type f -mtime +10           < найти файлы с mtime старше 10 дней
find . -type f -mtime +10 -mtime -20    <   найти файлы с mtime в диапазоне от 10 до 20 дней
find . -type f -delete              < удалить найденное
find . -type f -exec echo "founded {}" \;   < передать найденное внешней команде 
find ./* -type f | xargs -0 -i mv {} {}.rename  < обработать найденное через xargs

Удаление пустых папок:
find . -type d -empty -delete
find . -type d -empty rmdir {} \;
Удаление файлов по маске, игнорируя регистр символов:
find . -type f -name -iname "**.LnK*" -delete

| xargs

[команда_генератор_списка] | xargs [опции_xargs] [команда]

find . -name "*.sh" | xargs rm -rf


Шпаргалка по регуляркам:
[0-9]                   — Любая цифра
[a-z][A-Z][a-zA-Z]      — 3 примера сразу: строчные буквы, прописные буквы, и те и другие буквы
[^0-9][^a-zA-Z]         — 2 примера: всё кроме цифр, всё кроме букв (“крышечка” – отрицание)
{2-5}                   — Модификатор “число повторений”
[0-9]{2}                — Число из двух цифр
[а-яА-Я]{2,5}           — Слово не короче двух и не длиннее пяти букв

^                       — Начало строки
$                       — Конец строки
^Otus                   — Строка начинается со слова Otus
Otus$                   — Строка заканчивается словом Otus
^Otus$                  — Строка состоит из слова Otus и больше в ней ничего нет

.                       — заменяет любой символ (любой один символ)
*                       — модификатор “ноль или больше”
+                       — модификатор “один или больше”
O.us                    — Подходит: Otus, Opus, Oous. Не подходит: Ous, Ottus
O.*us                   — Подходит: Otus, Opus, Oous, Ottus, Ous. Не подходит: OttUS Otsu
O.+us                   — Подходит: Otus, Opus, Oous, Ottus. Не подходит: Ous Otsu

[0-9]*                  — Ноль или больше цифр
[0-9]+[a-zA-Z]{2}       — Как минимум 1 цифра (или больше одной) и ровно 2 буквы
(42|31)                 — Вертикальная черта | означает “или”. В данном примере ищем или 42 или 31